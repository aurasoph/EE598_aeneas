-- THIS FILE WAS AUTOMATICALLY GENERATED BY AENEAS
-- [rust_list]
import Aeneas
open Aeneas.Std Result Error
set_option linter.dupNamespace false
set_option linter.hashCommand false
set_option linter.unusedVariables false

namespace rust_list

/- [rust_list::Node]
   Source: 'src/lib.rs', lines 6:0-9:1 -/
inductive Node where
| mk : I32 → Option Node → Node

def Node.elem (x : Node) := match x with | Node.mk x1 _ => x1

def Node.next (x : Node) := match x with | Node.mk _ x1 => x1

@[simp]
theorem Node.elem._simpLemma_ (elem : I32) (next : Option Node) :
  (Node.mk elem next).elem = elem := by rfl

@[simp]
theorem Node.next._simpLemma_ (elem : I32) (next : Option Node) :
  (Node.mk elem next).next = next := by rfl

/- [rust_list::List]
   Source: 'src/lib.rs', lines 11:0-13:1 -/
structure List where
  head : Option Node

/- [rust_list::{rust_list::List}::new]:
   Source: 'src/lib.rs', lines 16:4-18:5 -/
def List.new : Result List := do
  ok { head := none }

/- [rust_list::{rust_list::List}::is_empty]:
   Source: 'src/lib.rs', lines 20:4-22:5 -/
def List.is_empty (self : List) : Result Bool := do
  ok (core.option.Option.is_none self.head)

/- [rust_list::{rust_list::List}::push_front]:
   Source: 'src/lib.rs', lines 24:4-30:5 -/
def List.push_front (self : List) (x : I32) : Result List := do
  let (o, _) := core.option.Option.take self.head
  ok { head := (some (Node.mk x o)) }

/- [rust_list::{rust_list::List}::push_back]: loop 0:
   Source: 'src/lib.rs', lines 36:12-43:17 -/
def List.push_back_loop
  (cur : Option Node) : Result (Option Node → Option Node) := do
  match cur with
  | none => ok (fun o => o)
  | some node =>
    let back ← List.push_back_loop node.next
    ok (fun o => let o1 := back o
                 some (Node.mk node.elem o1))
partial_fixpoint

/- [rust_list::{rust_list::List}::push_back]:
   Source: 'src/lib.rs', lines 33:4-46:5 -/
def List.push_back (self : List) (x : I32) : Result List := do
  let back ← List.push_back_loop self.head
  let o := back (some (Node.mk x none))
  ok { head := o }

/- [rust_list::{rust_list::List}::append]: loop 0:
   Source: 'src/lib.rs', lines 1:0-71:9 -/
def List.append_loop
  (other : List) (cur : Option Node) : Result (Option Node) := do
  match cur with
  | none => let (cur1, _) := core.option.Option.take other.head
            ok cur1
  | some node =>
    let b := core.option.Option.is_none node.next
    if b
    then
      let (o, _) := core.option.Option.take other.head
      ok (some (Node.mk node.elem o))
    else
      let back ← List.append_loop other node.next
      ok (some (Node.mk node.elem back))
partial_fixpoint

/- [rust_list::{rust_list::List}::append]:
   Source: 'src/lib.rs', lines 49:4-72:5 -/
def List.append (self : List) (other : List) : Result List := do
  let b := core.option.Option.is_none self.head
  if b
  then let (o, _) := core.option.Option.take other.head
       ok { head := o }
  else let back ← List.append_loop other self.head
       ok { head := back }

/- [rust_list::{rust_list::List}::reverse_iter]: loop 0:
   Source: 'src/lib.rs', lines 79:8-84:9 -/
def List.reverse_iter_loop
  (prev : Option Node) (cur : Option Node) : Result (Option Node) := do
  match cur with
  | none => ok prev
  | some boxed =>
    let (next, _) := core.option.Option.take boxed.next
    List.reverse_iter_loop (some (Node.mk boxed.elem prev)) next
partial_fixpoint

/- [rust_list::{rust_list::List}::reverse_iter]:
   Source: 'src/lib.rs', lines 75:4-87:5 -/
def List.reverse_iter (self : List) : Result List := do
  let (cur, _) := core.option.Option.take self.head
  let prev ← List.reverse_iter_loop none cur
  ok { head := prev }

end rust_list
